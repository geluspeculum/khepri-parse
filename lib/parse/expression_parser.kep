/**
 * @fileOverview Khepri expression parsers.
 */
package (
    arrayLiteral
    
// Object Literal
    propertyName
    propertyInitializer
    objectProperties
    objectLiteral
    
// Function
    functionExpression
    
// Operator
    operatorExpression
    
    primaryExpression
    
// Curry Expression
    curryExpression
    
// Call Expression
    args
    
// Application Expression
    applicationExpression
    
// Member Expression
    dotAccessor
    bracketAccessor
    accessor
    memberExpression
    
// New Expression
    newExpression
    
// Unary Expression
    unaryOperator
    unaryExpression
    
// Binary Expression
    binaryExpression
    
// Conditional Expression
    conditionalExpression

// Let Expression
    letExpression

// Do Expression
    doExpression
    
// Assignment
    leftHandReferenceExpression
    assignmentOperator
    assignmentExpression

// Expression
    expression
    topLevelExpression)
with
    import 'bennu::parse' {
        always
        append
        attempt
        bind
        binds
        choice
        eager
        either
        enumeration
        expected
        many
        memo
        next
        optional
        rec
        late
        label},
    import 'bennu::lang' {
        between
        chainl1
        chainr1
        sepBy
        sepBy1
        then},
    import 'nu-stream::stream' {foldl foldr},
    
    import 'khepri-ast::declaration' ast_declaration,
    import 'khepri-ast::expression' ast_expression,
    import 'khepri-ast::statement' ast_statement,
    import 'khepri-ast::pattern' ast_pattern,
    import 'khepri-ast::value' ast_value,
    import 'khepri-ast::position' {SourceLocation},
    
    import './common' {node nodea precedence},
    import './token_parser' {keyword punctuator},
    import './program_parser' program_parser,
    import './value_parser' {identifier literal stringLiteral},
    import './pattern_parser' pattern
in {

/* Circular Declarations 
 ******************************************************************************/
var blockStatement = late\-> {
    with
        import './statement_parser' {blockStatement}
    in {
        return blockStatement;
    }
};

/* Forward Declarations
 ******************************************************************************/
expression = late\-> expression;

memberExpression = late\-> memberExpression;

curryExpression = late\-> memberExpression;

/* labels
 ******************************************************************************/
// Array Literal
////////////////////////////////////////
arrayLiteral = label@'Array Literal' <| let
    arrayElement = expression,
    
    arrayElements =
        eager <| sepBy(punctuator ',',
            arrayElement)
in
    node(
        between(punctuator '[', punctuator ']',
            arrayElements),
        ast_expression.ArrayExpression.create);

// Object Literal
////////////////////////////////////////
propertyName = stringLiteral;

propertyInitializer = label@'Property Initializer' <|
    nodea(
        enumeration(
            then(
                propertyName,
                punctuator ':'),
            expression),
        ast_value.ObjectValue.create);

objectProperties = label@'Object Properties' <|
    eager <| sepBy(punctuator ',',
        propertyInitializer);

objectLiteral = label@'Object Literal' <|
    node(
        between(punctuator '{', punctuator '}',
            objectProperties),
        ast_expression.ObjectExpression.create);

// Function Expression
////////////////////////////////////////
functionExpression = label@'Function Expression' <| let
    functionBody =
        either(
            blockStatement,
            expression)
in
    nodea(
        enumeration(
            optional(null, next(
                keyword 'function',
                optional(null, identifier))),
            next(
                punctuator '\\',
                pattern.argumentsPattern),
            next(
                punctuator '->',
                functionBody |> expected@"function body")),
        ast_expression.FunctionExpression.create);

// Let Expression
////////////////////////////////////////
var letBinding = label@'Let Binding' <|
    nodea(
        enumeration(
            pattern.topLevelPattern |> expected@'pattern',
            punctuator('=', '=:', ':='),
            expression |> expected@'bound value'),
       \loc pattern rec expr ->
            ast_declaration.Binding.create(loc,
                pattern,
                expr,
                (rec.value === ':=')));

letExpression = label@'Let Expression' <| let
    letBindings =
        sepBy1(punctuator ',',
            letBinding),
    
    letBody = expression
in
    nodea(
        next(
            keyword 'let',
            enumeration(
                eager letBindings |> expected@'let bindings',
                next(
                    keyword 'in',
                    letBody |> expected@'let body expression'))),
        ast_expression.LetExpression.create);

// Do Expression
////////////////////////////////////////
var yieldExpression = label@'Yield Expression' <|
    node(
        next(
            keyword 'yield',
            expression),
        ast_expression.YieldExpression.create);

var doBinding = label@'Do Binding' <|
    nodea(
        enumeration(
            pattern.topLevelPattern |> expected@'pattern',
            next(
                punctuator '<-',
                expression |> expected@'bound value')),
        ast_declaration.Binding.create);

doExpression = label@'Do Expression' <| let
    doBindings = sepBy(punctuator ',',
        doBinding)
        |> expected@'do bindings',
    
    doBody = either(
        yieldExpression,
        next(
            keyword 'in',
            expression
                |> expected@'do body'))
in
    nodea(
        next(
            keyword 'do',
            enumeration(
                between(punctuator '(', punctuator')',
                    optional(null, expression)),
                eager doBindings,
                doBody)),
        ast_expression.DoExpression.create);

// Conditional Expression
////////////////////////////////////////
conditionalExpression = label@'Conditional Expression' <|
    nodea(
        next(
            punctuator '?',
            enumeration(
                expression,
                next(
                    punctuator ':',
                    expression
                    |> expected@"conditional consequent expression"),
                next(
                    punctuator ':',
                    expression
                    |> expected@"conditional alternate expression"))),
        ast_expression.ConditionalExpression.create);

// Operators Expression
////////////////////////////////////////
var unaryOperatorExpression = label@'Unary Operator Expression' <|
    bind(
        either(
            keyword 'typeof',
            punctuator(
                'void',
                '~',
                '!',
                '++',
                '--')),
        \{loc, value} -> always(ast_expression.UnaryOperatorExpression.create(loc, value)));

var binaryOperatorExpression = label@'Binary Operator Expression' <|
    bind(
        either(
            keyword 'instanceof',
            punctuator(
                '.',
                '*',
                '/',
                '+',
                '-',
                '%',
                '<<',
                '>>',
                '>>>',
                '<',
                '>',
                '<=',
                '>=',
                '==',
                '!=',
                '===',
                '!==',
                '&',
                '^',
                '|',
                '||',
                '&&',
                '|>',
                '\\>',
                '\\>>',
                '<|',
                '<\\',
                '<<\\')),
        \{loc, value} -> always(ast_expression.BinaryOperatorExpression.create(loc, value)));

var ternayOperatorExpression = label@'Ternary Operator Expression' <|
    bind(
        punctuator '?',
        \{loc, value} -> always(ast_expression.TernaryOperatorExpression.create(loc, value)));

operatorExpression = label@'Operator Expression' <| let
    op = choice(
        unaryOperatorExpression,
        binaryOperatorExpression,
        ternayOperatorExpression)
in
    nodea(
        between(punctuator '(', punctuator ')',
            enumeration(
                op,
                optional(null,
                    next(
                        punctuator ',',
                        eager <| sepBy1(punctuator ',',
                            expression |> expected@"argument"))))),
        \loc target args ->
            ?args
                :ast_expression.CurryExpression.create(loc, target, args)
                :target);

// Primary Expression
////////////////////////////////////////
primaryExpression = label@'Primary Expression' <|
    choice(
        letExpression,
        doExpression,
        conditionalExpression,
        identifier,
        literal,
        arrayLiteral,
        objectLiteral,
        functionExpression,
        attempt <| operatorExpression,
        between(punctuator '(', punctuator ')',
            expression |> expected@"expression"));

// args
////////////////////////////////////////
args = label@'Arguments' <| let
    element = expression |> expected@"argument"
in
    node(
        between(punctuator '(', punctuator ')',
            eager <| sepBy(punctuator ',', element)),
        \loc x -> {
            x.loc = loc;
            return x;
        });

// Accessor
////////////////////////////////////////
accessor = label@'Accessor' <|
    node(
        next(
            punctuator '.',
            either(
                bind(identifier, \x -> always([x, false])),
                bind(
                    between(punctuator '(', punctuator ')',
                        expression |> expected@"accessor expression"),
                    \x -> always([x, true])))),
        \loc [x computed] -> ({
            'loc': loc,
            'property': x,
            'computed': computed
        }));

// New Expression
////////////////////////////////////////
newExpression = label@'New Expression' <|
    nodea(
        next(
            keyword 'new',
            enumeration(
                memberExpression |> expected@"member expression",
                either(
                    args,
                    curryExpression)
                    |> expected@"argument list")),
        ast_expression.NewExpression.create);

// Member Expression
////////////////////////////////////////
var accessorReducer = \p, c -> 
    ast_expression.MemberExpression.create(
        SourceLocation.merge(p.loc, c.loc),
        p,
        c.property,
        c.computed);

memberExpression = label@'Member Expression' <|
    binds(
        enumeration(
            either(
                primaryExpression,
                newExpression),
            many accessor),
        foldl@accessorReducer \>> always);

// Lefthand side Expression
////////////////////////////////////////
var leftHandSideExpression = label@'Call Expression' <| let
    reducer = \p c ->
        ?c.hasOwnProperty('property')
            :ast_expression.MemberExpression.create(
                SourceLocation.merge(p.loc, c.loc),
                p,
                c.property,
                c.computed)
            :ast_expression.CallExpression.create(
                SourceLocation.merge(p.loc, c.loc),
                p,
                c)
in
    binds(
        enumeration(
            memberExpression,
            many <| either(args, accessor)),
        foldl@reducer \>> always);

// Curry Expression
////////////////////////////////////////
curryExpression = label@'Curry Expression' <| let
    reducer = \f args -> 
        ast_expression.CurryExpression.create(
            SourceLocation.merge(f.loc, args.loc),
            f,
            [].concat(args))
in
    binds(
        enumeration(
            leftHandSideExpression,
            many(
                next(
                    punctuator '@',
                    either(
                        args,
                        leftHandSideExpression)
                    |> expected@'curry argument'))),
        foldl@reducer \>> always);

// Application Expression
////////////////////////////////////////
applicationExpression = label@'Call Expression' <|
    chainl1(
        always <|\p c ->
            ast_expression.CallExpression.create(
                SourceLocation.merge(p.loc, c.loc),
                p,
                [c]),
        curryExpression);

// Unary Expression
////////////////////////////////////////
unaryOperator = label@'Unary Operator' <|
    either(
        keyword('typeof', 'void'),
        punctuator('++', '--', '~', '!'));

unaryExpression = label@'Unary Expression' <| let
    reducer = \argument op -> 
        ast_expression.UnaryExpression.create(
            SourceLocation.merge(op.loc, argument.loc),
            op.value,
            argument)
in
    binds(
        enumeration(
            many unaryOperator,
            applicationExpression |> expected@"unary argument"),
        \ops, expression ->
            always(foldr(reducer, expression, ops)));

// Binary Expressions
////////////////////////////////////////
var precedenceTable = [
    {
        'sep': punctuator('*', '/', '%'),
        'precedence': 1,
        'node': ast_expression.BinaryExpression
    }, {
        'sep': punctuator('+', '-'),
        'precedence': 2,
        'node': ast_expression.BinaryExpression
    }, {
        'sep': punctuator('<<', '>>', '>>>'),
        'precedence': 3,
        'node': ast_expression.BinaryExpression
    }, {
        'sep': either(
            punctuator('<', '>', '<=', '>='),
            keyword 'instanceof'),
        'precedence': 4,
        'node': ast_expression.BinaryExpression
    }, {
        'sep':  punctuator('==', '!=', '===', '!=='),
        'precedence': 5,
        'node': ast_expression.BinaryExpression
    }, {
        'sep': punctuator '&',
        'precedence': 6,
        'node': ast_expression.BinaryExpression
    }, {
        'sep': punctuator '^',
        'precedence': 7,
        'node': ast_expression.BinaryExpression
    }, {
        'sep': punctuator '|',
        'precedence': 8,
        'node': ast_expression.BinaryExpression
    }, {
        'sep': punctuator('\\>', '\\>>'),
        'precedence': 9,
        'node': ast_expression.BinaryExpression
    }, {
        'sep': punctuator('<\\', '<<\\'),
        'precedence': 9,
        'right': true,
        'node': ast_expression.BinaryExpression
    }, {
        'sep': punctuator '|>',
        'precedence': 10,
        'node': ast_expression.BinaryExpression
    }, {
        'sep': punctuator '<|',
        'precedence': 10,
        'right': true,
        'node': ast_expression.BinaryExpression
    }, {
        'sep': punctuator '||',
        'precedence': 11,
        'node': ast_expression.LogicalExpression
    }, {
        'sep': punctuator '&&',
        'precedence': 12,
        'node': ast_expression.LogicalExpression
    }
];

binaryExpression = label@'Binary Expression' <|
    precedence(
        unaryExpression |> memo,
        precedenceTable);

// Expression
////////////////////////////////////////
expression = binaryExpression;

// Left Hand Reference Expression
////////////////////////////////////////
leftHandReferenceExpression = label@'Left Hand Reference Expression' <|
    binds(
        enumeration(
            identifier |> memo,
            many accessor |> memo),
        foldl@accessorReducer \>> always);

// Assignment Expression
////////////////////////////////////////
assignmentOperator = punctuator '=';

assignmentExpression = label@'Assignment Expression' <|
    nodea(
        append(
            attempt <| enumeration(
                leftHandReferenceExpression,
                assignmentOperator),
            enumeration(
                expression |> expected@'expression')),
        \loc, left, op, right ->
            ast_expression.AssignmentExpression.create(loc, op.value, left, right));

// Delete Expression
////////////////////////////////////////
var deleteOperator = keyword 'delete';

var deleteExpression = label@'Delete Expression' <|
    nodea(
        enumeration(
            deleteOperator,
            leftHandReferenceExpression |> expected@'reference expression'),
        \loc op expression ->
            ast_expression.UnaryExpression.create(loc, op.value, expression));

// Top Level Expression
////////////////////////////////////////
topLevelExpression = choice(
    deleteExpression,
    assignmentExpression,
    expression);

}