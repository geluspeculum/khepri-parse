/**
 * @fileOverview 
 */
package (
    precedence,
    node,
    nodea,
    positionParser)
with
    import 'bennu::parse' parse#{
        always
        bind
        binds
        extract
        enumeration
        eager
        optional},
    import 'nu-stream::stream' stream#{NIL},

    import 'khepri-ast::position' {SourceLocation}
in {

var pres := \list -> {
    var stack = [],
        out = [];
    
    while (list.length > 0) {
        var tok = list.shift();
        if (tok.type) {
            out.push(tok);
        } else {
            while (stack.length > 0)
            with
                o2 = stack.(stack.length - 1)
            in {
                if ((!tok.right && o2.precedence === tok.precedence) ||
                  (o2.precedence < tok.precedence)) {
                    stack.pop();
                    with
                        rt = out.pop(),
                        lf = out.pop()
                    in {
                        out.push(o2.node(
                            SourceLocation.merge(lf.loc, rt.loc),
                            o2.value,
                            lf,
                            rt));
                    }
                } else {
                    break;
                }
            }
            stack.push(tok);
        }
    }
    
    while (stack.length > 0)
    with
        o = stack.pop(),
        rt = out.pop(),
        lf = out.pop()
    in {
        out.push(o.node(
            SourceLocation.merge(lf.loc, rt.loc),
            o.value,
            lf,
            rt));
    }
    return out.pop();
};

// Operator Precedence
////////////////////////////////////////
precedence = \p table -> let
    sep =
        parse.choicea <|
            table.map \ entry ->
                entry.sep.map \ value -> ({
                    value: value,
                    node: entry.node,
                    precedence: entry.precedence,
                    right: entry.right
                })
in
    eager(parse.rec\self ->
        parse.cons(p,
            optional(NIL,
                parse.cons(sep,
                    parse.expected("binary expression", self)))))
            .map(pres);

// State Interaction
////////////////////////////////////////
positionParser = extract \{position} -> position.sourcePosition;

var prevEnd = extract \{position} -> position.prevEnd;

// Ast Node
////////////////////////////////////////
node = \p, f ->
    binds(
        enumeration(
            positionParser,
            p,
            prevEnd),
        \o, x, c ->
            always <| f(new SourceLocation(o, c), x));

nodea = \p, f ->
    binds(
        enumeration(
            positionParser,
            p,
            prevEnd),
        \o, x, c ->
            always <| f.apply(undefined, stream.toArray(stream.cons(new SourceLocation(o , c), x))));

}