/**
 * @fileOverview Khepri identifier lexers
 */
package (
    zwnj
    zwj
    unicodeLetter
    unicodeDigit
    unicodeConnectorPunctuation
    
// Parts
    identifierStart
    identifierPart
    identifierParts
    identifierName
    
// Identifier
    identifier)
with
    import 'bennu::parse' {
        always
        bind
        cons
        choice
        either
        fail
        many
        next
        label},
    import 'bennu::text' {
        character
        oneOf
        digit
        letter
        string},
    import 'nu-stream::stream' {foldl},
    import './reserved_word_lexer' {reservedWordList}
in {

var join := foldl@ (+) @ '';

/* Lexers
 ******************************************************************************/
// Characters
////////////////////////////////////////
/**
 * Zero Width non-joiner
 */
zwnj := character '\u200c';

/**
 * Zero Width joiner
 */
zwj := character '\u200d';

/**
 * Lexer for a unicode letter character.
 * 
 * Any character in any of the Unicode categories:
 * - Uppercase letter (Lu)
 * - Lowercase letter (Ll)
 * - Titlecase letter (Lt)
 * - Modifier letter (Lm)
 * - Other letter (Lo)
 * - Letter number (Nl)
 * 
 * @TODO Implement for unicode based on spec.
 */
unicodeLetter := letter;

/**
 * Lexer for a Unicode digit character.
 * 
 * Any character in the Unicode category Decimal number (Nd).
 * 
 * @TODO Implement for unicode based on spec.
 */
unicodeDigit := digit;

/**
 * Lexer for a Unicode connector punctuation character.
 * 
 * Any character in the Unicode category Connector Punctuation (Pc).
 */
unicodeConnectorPunctuation := oneOf [
    '\u005F',
    '\u203F',
    '\u2040',
    '\u2054',
    '\uFE33',
    '\uFE34',
    '\uFE4D',
    '\uFE4E',
    '\uFE4F',
    '\uFF3F'];

// Parts
////////////////////////////////////////
identifierStart := either(
    unicodeLetter,
    oneOf '$_');

identifierPart := choice(
    identifierStart,
    unicodeDigit,
    unicodeConnectorPunctuation,
    zwnj,
    zwj);

identifierParts := many identifierPart;

/**
 * Identifier.
 * 
 * May be a keyword.
 */
identifierName := cons(identifierStart, identifierParts);

// Identifier
////////////////////////////////////////
/**
 * Lexer for an identifier.
 * 
 * Checks to make sure returned identifier is not a keyword.
 */
identifier := label@'Identifier Lexer' <|
    bind(identifierName, \name -> let n = join name in
        ?reservedWordList.indexOf(n) >= 0
            :fail()
            :always n);

}