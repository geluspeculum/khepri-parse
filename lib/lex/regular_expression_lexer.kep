/**
 * @fileOverview Khepri regular expression lexers.
 */
package (
    regularExpressionNonTerminator,
    regularExpressionBackslashSequence,
    
// Class
    regularExpressionClassChar,
    regularExpressionClassChars,
    regularExpressionClass,
    
// Characters
    regularExpressionChar,
    regularExpressionChars,
    regularExpressionFirstChar,
    
// Parts
    regularExpressionFlags,
    regularExpressionBody,
    
// Regex Literal
    regularExpressionLiteral)
with
    import 'bennu::parse' {
        always
        attempt
        anyToken
        bind
        binds
        choice
        cons
        either
        enumeration
        many
        map
        next
        not
        label
        token},
    import 'bennu::lang' {between},
    import 'bennu::text' {character noneOf},
    import 'nu-stream::stream' {foldl},
    import './identifier_lexer' {identifierPart},
    import './line_terminator_lexer' {lineTerminator}
in {

var join := foldl @ (+) @ '';

/* Lexers
 ******************************************************************************/
// Parts
////////////////////////////////////////
regularExpressionNonTerminator =
    next(
        not lineTerminator,
        anyToken);

regularExpressionBackslashSequence := next(
    character '\\',
    map(
        (+ '\\'),
        regularExpressionNonTerminator));

// Class
////////////////////////////////////////
regularExpressionClassChar := either(
    next(
        not lineTerminator,
        noneOf ']\\'),
    regularExpressionBackslashSequence);

regularExpressionClassChars := many regularExpressionClassChar;

regularExpressionClass := between(character '[', character ']', 
    map(
        \body ->
            '[' + join body + ']',
        regularExpressionClassChars));

// Characters
////////////////////////////////////////
regularExpressionFirstChar := choice(
    next(
        not lineTerminator,
        noneOf '*\\`['),
    regularExpressionBackslashSequence,
    regularExpressionClass);

regularExpressionChar := choice(
    next(
        not lineTerminator,
        noneOf '\\`['),
    regularExpressionBackslashSequence,
    regularExpressionClass);

regularExpressionChars := many regularExpressionChar;

// Literal Parts
////////////////////////////////////////
regularExpressionFlags := many identifierPart;

regularExpressionBody := map(
    join,
    cons(
        regularExpressionFirstChar,
        regularExpressionChars));

// Literal
////////////////////////////////////////
/**
 * Lexer for regular expression literals.
 */
regularExpressionLiteral := label@'Regular Expression Lexer' <|
    binds(
        enumeration(
            between(character '`', character '`',
                regularExpressionBody),
            regularExpressionFlags),
        \body, flags -> always(new RegExp(body, join(flags))));

}