/**
 * @fileOverview Khepri lexers.
 */
package (
    literal
    token
    inputElement
    lexer
    lexManyState
    lex)
with
    import 'bennu::parse' parse#{
        always
        attempt
        binds
        bind
        choice
        either
        eof
        getPosition
        enumeration
        extract
        expected
        next
        many
        runState
        Parser
        ParserState},
    import 'bennu::lang' {then},
    import 'nu-stream::stream' {memoStream, NIL, 'from': streamFrom},
    
    import 'khepri-ast::token' lexToken,
    import 'khepri-ast::position' {SourceLocation, SourcePosition},
    
    import './boolean_lexer' {booleanLiteral},
    import './comment_lexer' {comment},
    import './identifier_lexer' {identifier, identifierName},
    import './line_terminator_lexer' {lineTerminator},
    import './null_lexer' {nullLiteral},
    import './number_lexer' {numericLiteral},
    import './punctuator_lexer' {punctuator},
    import './reserved_word_lexer' {reservedWord},
    import './string_lexer' {stringLiteral},
    import './whitespace_lexer' {whitespace},
    import './regular_expression_lexer' {regularExpressionLiteral}
in {

var makeToken = \type, p ->
    bind(p, \value -> always([type, value]));

var buildToken = \p ->
    binds(
        enumeration(
            getPosition,
            p,
            getPosition),
        \start, [type, value], end ->
            always(
                new type(
                    new SourceLocation(start, end),
                    value)));
/* Lexers
 ******************************************************************************/
var literalImpl = choice(
    makeToken(lexToken.StringToken, stringLiteral),
    makeToken(lexToken.RegularExpressionToken, regularExpressionLiteral),
    makeToken(lexToken.BooleanToken, booleanLiteral),
    makeToken(lexToken.NullToken, nullLiteral),
    makeToken(lexToken.NumberToken, numericLiteral));

var tokenImpl = choice(
    attempt <|
        makeToken(lexToken.IdentifierToken, identifier),
    attempt <|
        literalImpl,
    makeToken(lexToken.KeywordToken, reservedWord),
    makeToken(lexToken.PunctuatorToken, punctuator));

var inputElementImpl = choice(
    makeToken(lexToken.CommentToken, comment),
    makeToken(lexToken.WhitespaceToken, whitespace),
    makeToken(lexToken.LineTerminatorToken, lineTerminator),
    tokenImpl);

literal = buildToken(literalImpl);

token = buildToken(tokenImpl);

inputElement = buildToken(inputElementImpl);

lexer = then(
    many inputElement,
    eof);

/* Running
 ******************************************************************************/
lex = \input -> 
    runState(lexer,
        new ParserState(
            streamFrom(input),
            SourcePosition.initial));

}