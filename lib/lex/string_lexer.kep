/**
 * @fileOverview Khepri string literal lexers.
 */
package (
// Constants
    doubleQuote
    escape
    singleQuote
    lineContinuation
    
// Escape Sequences
    unicodeEscapeSequence
    hexEscapeSequence
    characterEscapeSequence
    escapeSequence
    
// Single String Literal
    singleStringCharacter
    singleStringCharacters
    singleStringLiteral
    
// Double String Literal
    doubleStringCharacter
    doubleStringCharacters
    doubleStringLiteral
    
// Literal
    stringLiteral)
with
    import 'bennu::parse' {
        always
        attempt
        bind
        choice
        either
        eof
        many
        map
        next
        sequence
        label
        test
        token},
    import 'bennu::text' {character},
    import 'bennu::lang' {between times},
    import 'nu-stream::stream' {foldl},
    
    import './line_terminator_lexer' {
        lineTerminatorSequence
        lineTerminator},
    import './number_lexer' {
        decimalDigit
        hexDigit}
in {

var join = foldl @ (+) @ '';

var fromCharCode = map @ \x ->
    String.fromCharCode(parseInt(join(x), 16));

/* Lexers
 ******************************************************************************/
// Constants
////////////////////////////////////////
doubleQuote = character '"';

singleQuote = character "'";

escape = character '\\';

lineContinuation = sequence(
    escape,
    lineTerminatorSequence,
    always '');

// Escape Character
////////////////////////////////////////
var singleEscapeCharacter = choice(
    doubleQuote,
    singleQuote,
    escape,
    next(character 'b', always '\u0008'),
    next(character 'f', always '\u000C'),
    next(character 'n', always '\u000A'),
    next(character 'r', always '\u000D'),
    next(character 't', always '\u0009'),
    next(character 'v', always '\u000B'));

var escapeCharacter = choice(
    singleEscapeCharacter,
    decimalDigit,
    character 'u',
    character 'x');

var nonEscapeCharacter = token <|\ tok ->
    !(test(escapeCharacter, tok) || test(lineTerminator, tok));

// Escape Sequence
////////////////////////////////////////
hexEscapeSequence = next(
    character 'x',
    hexDigit |> times@2 |> fromCharCode);

unicodeEscapeSequence = next(
    character 'u',
    hexDigit |> times@4 |> fromCharCode);

characterEscapeSequence = either(
    singleEscapeCharacter,
    nonEscapeCharacter);

escapeSequence = choice(
    characterEscapeSequence,
    sequence(
        character '0',
        either(
            eof,
            token((!) <\ test@decimalDigit)),
        always '\u0000'),
    hexEscapeSequence,
    unicodeEscapeSequence);

// Single String Literal
////////////////////////////////////////
/**
 * Character in single quoted string.
 */
singleStringCharacter = label@'Single String Character' <|
    choice(
        attempt lineContinuation,
        next(escape, escapeSequence),
        token <|\ tok ->
            !(test(singleQuote, tok) ||
                test(escape, tok) || 
                test(lineTerminator, tok)));

/**
 * Sequence of single string characters.
 */
singleStringCharacters = many singleStringCharacter;

/**
 * Single quoted string literal.
 * 
 * Returns the value of the string enclosed in the single quoted string literal.
 */
singleStringLiteral = label@'Single String Literal' <|
    between(singleQuote, singleQuote,
        map(join, singleStringCharacters));

// Double String Literal
////////////////////////////////////////
/**
 * Character in double quoted string.
 */
doubleStringCharacter = choice(
    attempt lineContinuation,
    next(escape, escapeSequence),
    token <|\ tok ->
        !(test(doubleQuote, tok) ||
            test(escape, tok) ||
            test(lineTerminator, tok)));

/**
 * Sequence of double string characters.
 */
doubleStringCharacters = many doubleStringCharacter;

/**
 * Double quoted string literal.
 * 
 * Returns the value of the string enclosed in the double quoted string literal.
 */
doubleStringLiteral = label@'Double String Literal' <|
    between(doubleQuote, doubleQuote,
        map(join, doubleStringCharacters));

// String Literal
////////////////////////////////////////
/**
 * String literal.
 * 
 * Returns the value of the string enclosed in the string literal.
 */
stringLiteral = label@'Sting Literal Lexer' <|
    either(
        singleStringLiteral,
        doubleStringLiteral);

}